## dslee	2016-04-21 10:53:42: renewed version 1
## dslee	2016-05-03 15:50:58: minor code fixes and another version of decryption method
## dslee    2017-03-31 01:09:15 -- file name was changed to 'aes_core.py'
## dslee    2017-04-21 21:00:17	--	all codes were integrated into this code that were in aes_etc.py, aes_tfs.py


import sys

# DEBUG_controls
SHOW_WHOLE_KEY_SCH=0
AES_DEBUG=0



# showStr: display arg in string format
#def showStr(arg):# {{{
#    out= ""
#    for col in range( 0,len(arg[0]) ):
#        for row in range( 0,len(arg) ):
#            out += "%02X"%arg[row][col]
#        out += " "
#    return out# }}}
def showStr(arg):
	return " ".join( ["%02X"%arg[r][c] for c in range(len(arg[0])) for r in range (len(arg))] )


# showMat: display state (in matrix form) info
# i| arg: state
# o| display state on stdout
def showMat(arg):
    for row in range(0,len(arg)):
        print( "| ", end="" )
        for col in range(0,len(arg[0])):
            print( "%02X " % arg[row][col], end="" )
            if col % len(arg[0]) == (len(arg[0])-1): print( " |" )

# genMat: string to matrix
# i| arg: input bytes, colCNT: #cols
# o| 4-by-colCNT matrix filled with input bytes(type: number, hex). See Figure 3, FIPS-197
def genMat(arg, colCNT):
    # DEBUG_controls
    DEBUG_arg = 0
    DEBUG_show_output = 0

    if DEBUG_arg == 1: print( "arg(%d): %s" % (len(arg), arg) )

    ## pad zeros at the right end of arg --> make length of arg to be 32
    #arg = arg.ljust(32, '0')
    # prepare out matrix, #cols=colCNT / #rows=4 
    out= [ ([0] * colCNT) for x in range(0,4) ]
    # DO NOT USE [ [0] * 4] * 4 --> it does not results 4-by-4 matrix filled with zero
    for col in range(0,colCNT):
        for row in range(0,4):
            out[row][col]= int( arg[ 8*col+2*row : 8*col+2*row + 2 ] , 16 )

    if DEBUG_show_output == 1: showMat(out)

    return out



# aesKBR: returns AES Key-Block-Round (Nk,Nb,Nr) combinations (Figure 4, FIPS-197)
# i| k: key
# o| (Nk,Nb,Nr)=(key_lengths,block_size,#rounds)
def aesKBR(k):
    if len(k)==32: return (4,4,10)
    if len(k)==48: return (6,4,12)
    if len(k)==64: return (8,4,14)


def MOD_GF28(dividend, divisor):
    # bitfield length is len(bin(arg))-2
    # ex) >>> len(bin(0x2c18))-2
    #     14
    while( len(bin(dividend)) >= len(bin(divisor)) ):
        dividend ^= divisor << ( len(bin(dividend)) - len(bin(divisor)) )
    return(dividend)

def MUL_GF28(arg1, arg2):
    ans= 0
    idx= 0
    while(arg2):
        #if arg2 % 2 == 1:
        if arg2&0x1 == 1:
            #ans ^= (arg1 * (2**idx))
            ans ^= (arg1<<idx)
        arg2 >>= 1
        idx += 1
    #print("ans: %d" % ans)
    return MOD_GF28(ans, 0x11b)
    # Note) irreducible polynomial for AES 128: x^8+x^4+x^3+x+1


# rotate a word for key matrix
def RotWord(arg):
    return [ arg[1], arg[2], arg[3], arg[0] ]



# SubBytes: perform SubBytes() with changing string to hex
SBT={0x00:0x63,0x01:0x7c,0x02:0x77,0x03:0x7b,0x04:0xf2,0x05:0x6b,0x06:0x6f,0x07:0xc5,0x08:0x30,0x09:0x01,0x0a:0x67,0x0b:0x2b,0x0c:0xfe,0x0d:0xd7,0x0e:0xab,0x0f:0x76,
0x10:0xca,0x11:0x82,0x12:0xc9,0x13:0x7d,0x14:0xfa,0x15:0x59,0x16:0x47,0x17:0xf0,0x18:0xad,0x19:0xd4,0x1a:0xa2,0x1b:0xaf,0x1c:0x9c,0x1d:0xa4,0x1e:0x72,0x1f:0xc0,
0x20:0xb7,0x21:0xfd,0x22:0x93,0x23:0x26,0x24:0x36,0x25:0x3f,0x26:0xf7,0x27:0xcc,0x28:0x34,0x29:0xa5,0x2a:0xe5,0x2b:0xf1,0x2c:0x71,0x2d:0xd8,0x2e:0x31,0x2f:0x15,
0x30:0x04,0x31:0xc7,0x32:0x23,0x33:0xc3,0x34:0x18,0x35:0x96,0x36:0x05,0x37:0x9a,0x38:0x07,0x39:0x12,0x3a:0x80,0x3b:0xe2,0x3c:0xeb,0x3d:0x27,0x3e:0xb2,0x3f:0x75,
0x40:0x09,0x41:0x83,0x42:0x2c,0x43:0x1a,0x44:0x1b,0x45:0x6e,0x46:0x5a,0x47:0xa0,0x48:0x52,0x49:0x3b,0x4a:0xd6,0x4b:0xb3,0x4c:0x29,0x4d:0xe3,0x4e:0x2f,0x4f:0x84,
0x50:0x53,0x51:0xd1,0x52:0x00,0x53:0xed,0x54:0x20,0x55:0xfc,0x56:0xb1,0x57:0x5b,0x58:0x6a,0x59:0xcb,0x5a:0xbe,0x5b:0x39,0x5c:0x4a,0x5d:0x4c,0x5e:0x58,0x5f:0xcf,
0x60:0xd0,0x61:0xef,0x62:0xaa,0x63:0xfb,0x64:0x43,0x65:0x4d,0x66:0x33,0x67:0x85,0x68:0x45,0x69:0xf9,0x6a:0x02,0x6b:0x7f,0x6c:0x50,0x6d:0x3c,0x6e:0x9f,0x6f:0xa8,
0x70:0x51,0x71:0xa3,0x72:0x40,0x73:0x8f,0x74:0x92,0x75:0x9d,0x76:0x38,0x77:0xf5,0x78:0xbc,0x79:0xb6,0x7a:0xda,0x7b:0x21,0x7c:0x10,0x7d:0xff,0x7e:0xf3,0x7f:0xd2,
0x80:0xcd,0x81:0x0c,0x82:0x13,0x83:0xec,0x84:0x5f,0x85:0x97,0x86:0x44,0x87:0x17,0x88:0xc4,0x89:0xa7,0x8a:0x7e,0x8b:0x3d,0x8c:0x64,0x8d:0x5d,0x8e:0x19,0x8f:0x73,
0x90:0x60,0x91:0x81,0x92:0x4f,0x93:0xdc,0x94:0x22,0x95:0x2a,0x96:0x90,0x97:0x88,0x98:0x46,0x99:0xee,0x9a:0xb8,0x9b:0x14,0x9c:0xde,0x9d:0x5e,0x9e:0x0b,0x9f:0xdb,
0xa0:0xe0,0xa1:0x32,0xa2:0x3a,0xa3:0x0a,0xa4:0x49,0xa5:0x06,0xa6:0x24,0xa7:0x5c,0xa8:0xc2,0xa9:0xd3,0xaa:0xac,0xab:0x62,0xac:0x91,0xad:0x95,0xae:0xe4,0xaf:0x79,
0xb0:0xe7,0xb1:0xc8,0xb2:0x37,0xb3:0x6d,0xb4:0x8d,0xb5:0xd5,0xb6:0x4e,0xb7:0xa9,0xb8:0x6c,0xb9:0x56,0xba:0xf4,0xbb:0xea,0xbc:0x65,0xbd:0x7a,0xbe:0xae,0xbf:0x08,
0xc0:0xba,0xc1:0x78,0xc2:0x25,0xc3:0x2e,0xc4:0x1c,0xc5:0xa6,0xc6:0xb4,0xc7:0xc6,0xc8:0xe8,0xc9:0xdd,0xca:0x74,0xcb:0x1f,0xcc:0x4b,0xcd:0xbd,0xce:0x8b,0xcf:0x8a,
0xd0:0x70,0xd1:0x3e,0xd2:0xb5,0xd3:0x66,0xd4:0x48,0xd5:0x03,0xd6:0xf6,0xd7:0x0e,0xd8:0x61,0xd9:0x35,0xda:0x57,0xdb:0xb9,0xdc:0x86,0xdd:0xc1,0xde:0x1d,0xdf:0x9e,
0xe0:0xe1,0xe1:0xf8,0xe2:0x98,0xe3:0x11,0xe4:0x69,0xe5:0xd9,0xe6:0x8e,0xe7:0x94,0xe8:0x9b,0xe9:0x1e,0xea:0x87,0xeb:0xe9,0xec:0xce,0xed:0x55,0xee:0x28,0xef:0xdf,
0xf0:0x8c,0xf1:0xa1,0xf2:0x89,0xf3:0x0d,0xf4:0xbf,0xf5:0xe6,0xf6:0x42,0xf7:0x68,0xf8:0x41,0xf9:0x99,0xfa:0x2d,0xfb:0x0f,0xfc:0xb0,0xfd:0x54,0xfe:0xbb,0xff:0x16}

InvSBT={0x00:0x52,0x01:0x09,0x02:0x6a,0x03:0xd5,0x04:0x30,0x05:0x36,0x06:0xa5,0x07:0x38,0x08:0xbf,0x09:0x40,0x0a:0xa3,0x0b:0x9e,0x0c:0x81,0x0d:0xf3,0x0e:0xd7,0x0f:0xfb,
0x10:0x7c,0x11:0xe3,0x12:0x39,0x13:0x82,0x14:0x9b,0x15:0x2f,0x16:0xff,0x17:0x87,0x18:0x34,0x19:0x8e,0x1a:0x43,0x1b:0x44,0x1c:0xc4,0x1d:0xde,0x1e:0xe9,0x1f:0xcb,
0x20:0x54,0x21:0x7b,0x22:0x94,0x23:0x32,0x24:0xa6,0x25:0xc2,0x26:0x23,0x27:0x3d,0x28:0xee,0x29:0x4c,0x2a:0x95,0x2b:0x0b,0x2c:0x42,0x2d:0xfa,0x2e:0xc3,0x2f:0x4e,
0x30:0x08,0x31:0x2e,0x32:0xa1,0x33:0x66,0x34:0x28,0x35:0xd9,0x36:0x24,0x37:0xb2,0x38:0x76,0x39:0x5b,0x3a:0xa2,0x3b:0x49,0x3c:0x6d,0x3d:0x8b,0x3e:0xd1,0x3f:0x25,
0x40:0x72,0x41:0xf8,0x42:0xf6,0x43:0x64,0x44:0x86,0x45:0x68,0x46:0x98,0x47:0x16,0x48:0xd4,0x49:0xa4,0x4a:0x5c,0x4b:0xcc,0x4c:0x5d,0x4d:0x65,0x4e:0xb6,0x4f:0x92,
0x50:0x6c,0x51:0x70,0x52:0x48,0x53:0x50,0x54:0xfd,0x55:0xed,0x56:0xb9,0x57:0xda,0x58:0x5e,0x59:0x15,0x5a:0x46,0x5b:0x57,0x5c:0xa7,0x5d:0x8d,0x5e:0x9d,0x5f:0x84,
0x60:0x90,0x61:0xd8,0x62:0xab,0x63:0x00,0x64:0x8c,0x65:0xbc,0x66:0xd3,0x67:0x0a,0x68:0xf7,0x69:0xe4,0x6a:0x58,0x6b:0x05,0x6c:0xb8,0x6d:0xb3,0x6e:0x45,0x6f:0x06,
0x70:0xd0,0x71:0x2c,0x72:0x1e,0x73:0x8f,0x74:0xca,0x75:0x3f,0x76:0x0f,0x77:0x02,0x78:0xc1,0x79:0xaf,0x7a:0xbd,0x7b:0x03,0x7c:0x01,0x7d:0x13,0x7e:0x8a,0x7f:0x6b,
0x80:0x3a,0x81:0x91,0x82:0x11,0x83:0x41,0x84:0x4f,0x85:0x67,0x86:0xdc,0x87:0xea,0x88:0x97,0x89:0xf2,0x8a:0xcf,0x8b:0xce,0x8c:0xf0,0x8d:0xb4,0x8e:0xe6,0x8f:0x73,
0x90:0x96,0x91:0xac,0x92:0x74,0x93:0x22,0x94:0xe7,0x95:0xad,0x96:0x35,0x97:0x85,0x98:0xe2,0x99:0xf9,0x9a:0x37,0x9b:0xe8,0x9c:0x1c,0x9d:0x75,0x9e:0xdf,0x9f:0x6e,
0xa0:0x47,0xa1:0xf1,0xa2:0x1a,0xa3:0x71,0xa4:0x1d,0xa5:0x29,0xa6:0xc5,0xa7:0x89,0xa8:0x6f,0xa9:0xb7,0xaa:0x62,0xab:0x0e,0xac:0xaa,0xad:0x18,0xae:0xbe,0xaf:0x1b,
0xb0:0xfc,0xb1:0x56,0xb2:0x3e,0xb3:0x4b,0xb4:0xc6,0xb5:0xd2,0xb6:0x79,0xb7:0x20,0xb8:0x9a,0xb9:0xdb,0xba:0xc0,0xbb:0xfe,0xbc:0x78,0xbd:0xcd,0xbe:0x5a,0xbf:0xf4,
0xc0:0x1f,0xc1:0xdd,0xc2:0xa8,0xc3:0x33,0xc4:0x88,0xc5:0x07,0xc6:0xc7,0xc7:0x31,0xc8:0xb1,0xc9:0x12,0xca:0x10,0xcb:0x59,0xcc:0x27,0xcd:0x80,0xce:0xec,0xcf:0x5f,
0xd0:0x60,0xd1:0x51,0xd2:0x7f,0xd3:0xa9,0xd4:0x19,0xd5:0xb5,0xd6:0x4a,0xd7:0x0d,0xd8:0x2d,0xd9:0xe5,0xda:0x7a,0xdb:0x9f,0xdc:0x93,0xdd:0xc9,0xde:0x9c,0xdf:0xef,
0xe0:0xa0,0xe1:0xe0,0xe2:0x3b,0xe3:0x4d,0xe4:0xae,0xe5:0x2a,0xe6:0xf5,0xe7:0xb0,0xe8:0xc8,0xe9:0xeb,0xea:0xbb,0xeb:0x3c,0xec:0x83,0xed:0x53,0xee:0x99,0xef:0x61,
0xf0:0x17,0xf1:0x2b,0xf2:0x04,0xf3:0x7e,0xf4:0xba,0xf5:0x77,0xf6:0xd6,0xf7:0x26,0xf8:0xe1,0xf9:0x69,0xfa:0x14,0xfb:0x63,0xfc:0x55,0xfd:0x21,0xfe:0x0c,0xff:0x7d}

def SubBytes(arg):
    Nb=4
    for col in range(0,Nb):
        for row in range(0,4):
            arg[row][col]= SBT[ arg[row][col] ]
    return arg

def InvSubBytes(arg):
    Nb=4
    for col in range(0,Nb):
        for row in range(0,4):
            arg[row][col]= InvSBT[ arg[row][col] ]
    return arg

def SubWord(arg):
    # the valid input is a list which length is 4
    if  len(arg) > 4:
        sys.exit("SubWord: argument length exceeds 4 bytes")

    if  len(arg) < 4:
        for i in range(0,4-len(arg)):   arg.append(0)

    for i in range(0,4):
        arg[i] = SBT[ arg[i] ]

    return arg


# ShiftRows
def ShiftRows(arg):
    Nb=4
    for row in range(0,4):
        arg[row]= arg[row][row:Nb]+arg[row][0:row]
    return arg

def InvShiftRows(arg):
    Nb=4
    for row in range(0,4):
        arg[row]= arg[row][Nb-row:Nb]+arg[row][0:Nb-row]
    return arg


# MixColumns
MATCOEFF_MIXCOL= [
[0x02,0x03,0x01,0x01],
[0x01,0x02,0x03,0x01],
[0x01,0x01,0x02,0x03],
[0x03,0x01,0x01,0x02]
]

InvMATCOEFF_MIXCOL= [
[0x0e,0x0b,0x0d,0x09],
[0x09,0x0e,0x0b,0x0d],
[0x0d,0x09,0x0e,0x0b],
[0x0b,0x0d,0x09,0x0e]
]


def MixColumns(arg, Nb):
    out = [ [0]*Nb for i in range(0,4) ]
    #out = [ [0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0] ]

    for col in range(0,Nb):
        # get columns from arg
        argCol = [ arg[0][col], arg[1][col], arg[2][col], arg[3][col] ]
        for row in range(0,4):
            for i in range(0,len(argCol)):
                # (m1 x n1) * (m2 * n2), m2 must be same with n1 for valid matrix multiplication
                if i == 0:
                    temp = MUL_GF28(MATCOEFF_MIXCOL[row][i],argCol[i])
                else:
                    temp ^= MUL_GF28(MATCOEFF_MIXCOL[row][i],argCol[i])
            out[row][col]= temp
            temp= 0
    return out


def InvMixColumns(arg, Nb):
    out = [ [0]*Nb for i in range(0,4) ]

    for col in range(0,Nb):
        # get columns from arg
        argCol = [ arg[0][col], arg[1][col], arg[2][col], arg[3][col] ]
        for row in range(0,4):
            for i in range(0,len(argCol)):
                # (m1 x n1) * (m2 * n2), m2 must be same with n1 for valid matrix multiplication
                if i == 0:
                    temp = MUL_GF28(InvMATCOEFF_MIXCOL[row][i],argCol[i])
                else:
                    temp ^= MUL_GF28(InvMATCOEFF_MIXCOL[row][i],argCol[i])
            out[row][col]= temp
            temp= 0
    return out



# addroundkeys
def AddRoundKey(state, key, currentNr, Nb):
	#print("Nb: %d" % Nb)
	# FOR DEBUG: print all round key
	DBG_show_all_round_key=0
	if DBG_show_all_round_key==1:
		print("round key %2d" % currentNr)
		for row in range(0,4):
			for col in range(0,Nb):
				print("%02X" % key[row][Nb*currentNr+col], end=" ")
			print("")
	for row in range(0,4):
		for col in range(0,Nb):
			state[row][col] ^= key[row][Nb*currentNr+col]
	return state


# generate Rcon matrix for key expansion
def genRcon_key_expand(Nr):
    Rcon= [ [0]*Nr for i in range(0,4) ]
    Rcon[0] = [ MOD_GF28(2**col,0x11b) for col in range(0,Nr) ]
    #print( "Rcon: %s" % str(Rcon) )
    return Rcon


# See Section 5.2 Key Expansion and Figure 11, FIPS-197
def KeyExpansion(key):
	(Nk,Nb,Nr)=aesKBR(key)
	# Put a given key into the key schedule table
	# Notice that colCNT = Nk
	out= genMat(key,Nk)
	#print("KeyExpansion out: " + str(out) )

	# generate the Rcon
	Rcon= genRcon_key_expand(Nr)

	# generate a key schedule
	for col in range(Nk,Nb*(Nr+1)):
		temp = [ out[i][col-1] for i in range(0,4) ]
		if col % Nk == 0:
			temp = SubWord(RotWord(temp))
			for row in range(0,4):
				temp[row] ^= Rcon[row][(col//Nk)-1]
		# for AES-256
		elif (Nk > 6) and (col % Nk == 4):
			temp = SubWord(temp)

		for row in range(0,4):
			out[row].append(out[row][col-Nk] ^ temp[row])

	return out



# encrypt = 1/0: encryption/decryption
def aes_core(k, d, encrypt):

	# check key length validity (valid when 128,192,256)
	if len(k)*4 not in [128,192,256]:
		sys.exit("aes: Key length is not one of 128,192,256")

	# Set key-block-round combinations (Nk, Nb, Nr)
	(Nk,Nb,Nr)=aesKBR(k)

	# initialize key
	key=""

	# state contains input data info, so #cols=Nb
	state= genMat(d,Nb)
	key = KeyExpansion(k)

	# FOR DEBUG: show key whole key schedule
	if SHOW_WHOLE_KEY_SCH==1:
		print("Whole key schedule")
		for j in range(0,len(key[0])):
			print(" %02d\t%02X%02X%02X%02X" % (j,key[0][j],key[1][j],key[2][j],key[3][j]) )
	# ---------------------------------------- #

	# encryption
	if encrypt==1:
		state= AddRoundKey(state, key, 0, Nb)
		# round = [ 1, 2, 3, ... , Nr-3, Nr-2, Nr-1 ]
		for round in range(1,Nr):
			state= SubBytes(state)
			state= ShiftRows(state)
			state= MixColumns(state, Nb)
			state= AddRoundKey(state, key, round, Nb)

		state= SubBytes(state)
		state= ShiftRows(state)
		state= AddRoundKey(state, key, Nr, Nb)

	# decryption
	elif encrypt==0:
		state= AddRoundKey(state, key, Nr, Nb)
		# round = [ Nr-1, Nr-2, Nr-3, ... , 2, 1, 0 ]
		for round in range(Nr-1,0,-1):
			state= InvShiftRows(state)
			state= InvSubBytes(state)
			state= AddRoundKey(state, key, round, Nb)
			state= InvMixColumns(state, Nb)
		state= InvShiftRows(state)
		state= InvSubBytes(state)
		state= AddRoundKey(state, key, 0, Nb)

	# another version of decryption
	elif encrypt==2:
		state= AddRoundKey(state, key, Nr, Nb)
		state= InvShiftRows(state)
		state= InvSubBytes(state)
		# round = [ Nr-1, Nr-2, Nr-3, ... , 2, 1, 0 ]
		for round in range(Nr-1,0,-1):
			state= AddRoundKey(state, key, round, Nb)
			state= InvMixColumns(state, Nb)
			state= InvShiftRows(state)
			state= InvSubBytes(state)
		state= AddRoundKey(state, key, 0, Nb)

	#return genStr(state)
	return  "%02x%02x%02x%02x" %   (state[0][0],state[1][0],state[2][0],state[3][0])+\
            "%02x%02x%02x%02x" %   (state[0][1],state[1][1],state[2][1],state[3][1])+\
            "%02x%02x%02x%02x" %   (state[0][2],state[1][2],state[2][2],state[3][2])+\
            "%02x%02x%02x%02x" %   (state[0][3],state[1][3],state[2][3],state[3][3])
